import mmm as mmm
import pyfits as py
import numpy as np
import ipdb as pdb
from matplotlib import pyplot as plt
import astro_tools as at
def measure_moms(fits_image, sex_catalog, outfile,
                     width=None, saturation=800000000, badval=-99,
                     cut_off=2.5, fieldback=0, mult=1,
                     min_rad=1.5, startx=0, starty=0,
                     silent=0,stellar=0, weight_image=None,
                     wt_ext=0,nocenter=0,gain=1,exp_time=1,
                     sgm_im='null',cat=None, nExposures = 1,
                     back=None, bad_val=-99, regfile=None,
                     skymed=None, skysd=None, return_moms=True):
                     
    '''
    ;
    ; NAME:                  rrg_measure_moms
    ;
    ; PURPOSE:
    ;    Uses the RRG method to measure the moments of objects in a fits image.  
    
    ;
    ; INPUTS:
    ;   fits_image- fits image with single extension
    ;   sex_catalog-SExtractor catalog in fits format
    ;   outfile- output file to store IDL array of variables
    ;
    ; OUTPUTS:
    ; stores moments and other info in the output file as an idl structure  
    ;
    ; KEYWORD PARAMETERS:
    ;   width- gaussian window function width, if not input is calculated from area
    ;   saturation,bad_value are saturation level and value of pixels not to use (outside image)
    ;   badval
    ;   cut_off- cut_off for measuring objects default is 2.5x width
    ;   fieldback -1 means use a field backgroup as calculated by IDL SKY, 0(default) uses object back from SEx
    ;   mult- multiplier used to find gaussian width from area
    ;   min_rad- stellar radius
    ;   startx, starty- lower left corner of image in pixel values, default to zero
    ;   silent set to 1 to supress messages
    ;   stellar set to 1 to evaluate all objects with the same radius (min_rad)
    ;   weight=use a weight image to determine good/bad pixels (yes=1 0=no/default)
    ;   wt_ext= extension of weight image in fits file
    ;  nocenter= if 1 then uses Sextractor centers and doesnt centroid
    ;  name_weight_im=name of the weight image
    ;  sgm_im Sextractor segmentation image to get sky background 
    ;  souces = predetermined sources to find
    ;MODIFICATION HISTORY:
    ;    30 Dec 2002 jrhodes
    ;    11 March 2003 jrhodes
    

    IF N_PARAMS(0) LT 1 THEN BEGIN
    PRINT, 'rrg_measure_moms,fits_image,sex_catalog,outfile,width=width,saturation=saturation,'
    PRINT, '    badval=badval,cut_off=cut_off,fieldback=fieldback,mult=mult,min_rad=min_rad,'
    PRINT, '    startx=startx,starty=starty,silent=silent,stellar=stellar,'
    PRINT, '    weight=weight,wt_ext=wt_ext,nocenter=nocenter,name_weight_im=name_weight_im'
    return
    ENDIF
    ;
    '''
                     
    img_file = py.open( fits_image )
    img = img_file[0].data
    imhead = img_file[0].header

    #What is mmm?
    if (skymed is None )|
        (skysd is None):
        skymed, skysd, skysw = mmm.mmm(img)
    
    print(' % f skymed and %f skysd' % (skymed,skysd))
    
    if cat is None:
        cat_file=py.open(sex_catalog)
        cat = cat_file[1].data
        header=cat_file[1].header
   
    nGalaxies = len(cat['X_IMAGE'])
    xGal, yGal = at.deg2pix( fits_image, cat['RA'], cat['DEC'] )
    #cat['X_IMAGE']
    #yGal = cat['Y_IMAGE']
    




    ysize= imhead['NAXIS2']
    xsize= imhead['NAXIS1']

    if weight_image is None:
        wt_image = np.ones( img.shape)
    else:
        wt_image = py.open( weight_image )[0].data



    prob=np.zeros(nGalaxies) #lets you know if there is a centerprob (2), badpixl(4),edgeprob (1)
    #The background for each galaxy. if none take from sex cata;pgue
    if back is None:
        try:
            back=cat.background
        except:
            back =  np.zeros( nGalaxies) + skysd
    else:
        back = np.zeros( nGalaxies) + back
    

    if (sgm_im != 'null') & (fieldback == 1):
        seg_file = py.open(sgm_im)
        seg = seg_file[0].data
        shdr = seg_file[0].header
        '''
        sel=where((seg eq 0)and (wt_image gt 0))
        mmm,img(sel),seg_sky,seg_skysd
        back=replicate(seg_sky,num) 
        '''
        
    radius=mult*np.sqrt(cat['area']/np.pi)
    
    radius[ radius < min_rad ] = min_rad

    
    if width is not None:
        radius=np.zeros(nGalaxies) + width
        
    cut_rad = radius*cut_off # cut off radius of object
    offedge=0 #;number of objects off the endge initially
    centerprob=0 # number of objects with centroiding problems
    badpix_prob=0 #number of objects with bad pixels

    galaxy_moments = moms( nGalaxies )
    for i in xrange( nGalaxies ):
        
        #following changed by jrhodes to account for different indexing in SExtractor and IDL
       

        deltax=1.0
        deltay=1.0
        count=1
        sum_int=0
        int_moms = moms( 1 )
        xc=xGal[i]-0.5
        yc=yGal[i]-0.5
        
        blank=0
        go_on=1
        badpix_centroid='no'
    
        if (xc-cut_rad[i]-1.< startx) | \
           (yc-cut_rad[i]-1 < starty) | \
           (xc+cut_rad[i]+1 > xsize ) | \
           (yc+cut_rad[i]+1 > ysize ):

            if not silent:
                print(' %i %f %f too close to edge at iteration 1\n' % (i,xGal[i],yGal[i]))
            offedge=offedge+1
            go_on=0
            prob[i] += 1



        #These are needed for all moments
        #Cut out a postage stamp of the image
        begin_x = np.round(xc-cut_rad[i]-1).astype(int)
        begin_y = np.round(yc-cut_rad[i]-1).astype(int)
        end_x = np.round(xc+cut_rad[i]+1).astype(int)
        end_y = np.round(yc+cut_rad[i]+1).astype(int)
    
    
        xvec = np.arange(begin_x, end_x)
        yvec = np.arange(begin_y, end_y)
    
        #this will be used throughotu the loop as well
        uncut_xgrid, uncut_ygrid = np.meshgrid( xvec, yvec)

        #Dist will also be used throughout the loop
        uncut_dist = np.sqrt( (uncut_xgrid - xc)**2 + \
                              (uncut_ygrid-yc)**2)
       
        #Also cut the images at the cut_radi
        dist = uncut_dist[uncut_dist < cut_rad[i]]
        xgrid = uncut_xgrid[uncut_dist < cut_rad[i]]
        ygrid = uncut_ygrid[uncut_dist < cut_rad[i]]
        
        #These will be used throughout the loop
        uncut_postage_stamp = img[begin_y:end_y, begin_x:end_x]
        postage_stamp = uncut_postage_stamp[uncut_dist < cut_rad[i]]
        
        uncut_postage_weight = wt_image[begin_y:end_y, begin_x:end_x]
        postage_weight = uncut_postage_weight[uncut_dist < cut_rad[i]]
        
        #This might be
        g_f = np.exp(-(dist**2)/(2.*radius[i]**2))
        weight_gal = g_f*( postage_stamp -  back[i])
        sum_int = np.sum( weight_gal )

        #Then finally change the dist ]
        #find the centroid
        if nocenter == 0:
            while  (np.abs(deltax) > 0.01) & \
                (np.abs(deltay) > 0.01) & \
                (count < 500) & (go_on == 1) :
   
                #changed from above line for SNAP sims jrhodes 7/09/07
                #used below for SNAP sims
                checkx=xc
                checky=yc

                #Get the centre
                xc = np.sum( weight_gal*(xgrid))/sum_int
                yc = np.sum( weight_gal*(ygrid))/sum_int

                count += 1
                deltax=xc-checkx
                deltay=yc-checky;
            
               
                if ( xc-cut_rad[i]-1 < startx) | \
                    ( yc-cut_rad[i]-1 < starty) | \
                    ( xc+cut_rad[i]+1 > xsize ) | \
                    ( yc+cut_rad[i]+1 > ysize) :
                    if not silent:
                        print( ' %i %f %f too close to edge at iteration %i' % \
                            (i,xGal[i],yGal[i],(count-1)) )
                        go_on=0
                        prob[i]=prob[i]+1
    
                if (badpix_centroid == 'yes'):
                    go_on=0
                    if not silent:
                        print( '%i %f %f  bad pix in centroid at iteration %f' %
                                    (i,xGal[i],yGal[i],(count-1)) )
                                
                        prob[i]=prob[i]+4
                        badpix_prob += 1
                        #End this if
                    #Ends the xc_ci of
                #this ends the while
            if (count > 100):
                centerprob=centerprob+1
                if not silent:
                    print( '%i %f %f Too many centering iterations %i' % \
                            (i,xGal[i],yGal[i],count))
                prob[i] += 2

            if np.sqrt( (xc-xGal[i])**2 + (yc-yGal[i])**2) > mult*radius[i]:
                go_on=0
                centerprob += 1
                if not silent:
                    print( '%i %f %f Centroid shift too large ' % (i,xGal[i],yGal[i]) )
                prob[i] += 2

        
            #this ends the centre befor the while
            #Now back into normal main galaxy loop
        badpix_mom='no'    
    # check for saturated pixels and bad pixels
        int_moms.x = xc
        int_moms.y = yc
        
        if go_on == 1:


            if (np.any(postage_stamp > saturation)) | \
                (np.any(postage_stamp == bad_val)) | \
                (np.any(postage_weight == 0)):
                go_on = 0
                prob[i] += 4
                badpix_mom='yes'
                
            if badpix_mom == 'yes':
                badpix_prob += 1 
                
                print('%i %f %f Bad pixel(s) in centroiding' %\
                        (i,xGal[i],yGal[i]))

        
    #find moments and center error
    

        if go_on == 1:
            rel_xgrid = xgrid - int_moms.x
            rel_ygrid = ygrid - int_moms.y
            
            int_moms.xx = np.sum(rel_xgrid*rel_xgrid*weight_gal) / sum_int
            int_moms.yy = np.sum(rel_ygrid*rel_ygrid*weight_gal) / sum_int
            int_moms.xy = np.sum(rel_xgrid*rel_ygrid*weight_gal) / sum_int



            int_moms.xxxx = np.sum(weight_gal*(rel_xgrid**4)) / sum_int
            int_moms.xxxy = np.sum(weight_gal*(rel_xgrid**3)*rel_ygrid)  / sum_int
            int_moms.xxyy = np.sum(weight_gal*(rel_xgrid**2)*(rel_ygrid**2)) / sum_int
            int_moms.xyyy=  np.sum(weight_gal*(rel_ygrid**3)*rel_xgrid)/ sum_int
            int_moms.yyyy = np.sum(weight_gal*(rel_ygrid**4)) / sum_int

         
           

            
            
            #find moment errors and covariances

            #Error in internsity
            I_err = np.sqrt( skysd**2+(postage_stamp-back[i])/( gain*exp_time)) / sum_int

            #Error in x and y
            sum_xxdI = np.sum(g_f*g_f*I_err*I_err*rel_xgrid*rel_xgrid) / sum_int
            sum_yydI = np.sum(g_f*g_f*I_err*I_err*rel_ygrid*rel_ygrid) / sum_int
            int_moms.error.x = np.sqrt(sum_xxdI)/sum_int
            int_moms.error.y = np.sqrt(sum_yydI)/sum_int

            #Error in second order
            int_moms.error.xx = np.sum(g_f*g_f*I_err*I_err*(rel_xgrid**2-int_moms.xx)**2)/sum_int
            int_moms.error.yy = np.sum(g_f*g_f*I_err*I_err*(rel_ygrid**2-int_moms.yy)**2)/sum_int
            int_moms.error.xy = np.sum(g_f*g_f*I_err*I_err*(rel_xgrid*rel_ygrid-int_moms.xy)**2)/sum_int

            #error in 4th order
            int_moms.error.xxyy = np.sum(g_f*g_f*I_err*I_err*\
                (rel_xgrid*rel_xgrid-int_moms.xx)*\
                (rel_ygrid*rel_ygrid-int_moms.yy))/sum_int**2
                          
            int_moms.error.xxxy = np.sum(g_f*g_f*I_err*I_err*\
                (rel_xgrid*rel_xgrid-int_moms.xx)*\
                (rel_ygrid*rel_xgrid-int_moms.yy))/sum_int**2
                        
            int_moms.error.xyyy = np.sum(g_f*g_f*I_err*I_err*\
                          (rel_xgrid*rel_xgrid-int_moms.xy)*\
                          (rel_ygrid*rel_ygrid-int_moms.yy))/sum_int**2

            

        else:
            int_moms.xx, int_moms.yy, int_moms.xy = [-99, -99, -99]
            int_moms.xxxx, int_moms.xxxy =  [0, 0]
            int_moms.xxyy, int_moms.xyyy, int_moms.yyyy = [0, 0, 0]
            int_moms.error.xx, int_moms.error.yy, int_moms.error.xy = [0, 0, 0]
            int_moms.error.xxxx, int_moms.error.xxxy =  [0, 0]
            int_moms.error.xxyy, int_moms.error.xyyy, int_moms.error.yyyy = [0, 0, 0]
            xc_err, yc_err = [0, 0]

        
        e1=(int_moms.xx -int_moms.yy)/(int_moms.xx+int_moms.yy)
        e2=(2*int_moms.xy)/(int_moms.xx+int_moms.yy)
        alpha=0.5*np.arctan2(e2,e1)
        
        galaxy_moments.append( i, int_moms )
        

    #Append some needed things
    galaxy_moments.ra = cat['RA']
    galaxy_moments.dec = cat['DEC']
    
   
    galaxy_moments.calc_e1e2( mult_rad=mult)     
    
    galaxy_moments.write_to_fits( outfile )
    if regfile is not None:
        galaxy_moments.fits_to_ellipse( regfile)
    
    if return_moms:
        return galaxy_moments

class moms:

    def __init__( self, ngalaxies, mk_error=True ):
        self.x = np.zeros( ngalaxies )
        self.y = np.zeros( ngalaxies )
        self.xx = np.zeros( ngalaxies )
        self.yy = np.zeros( ngalaxies )
        self.xy = np.zeros( ngalaxies )
        self.xxxx = np.zeros( ngalaxies)
        self.yyyy = np.zeros( ngalaxies)
        self.xxyy = np.zeros( ngalaxies)
        self.xyyy = np.zeros( ngalaxies)
        self.xxxy = np.zeros( ngalaxies)

        if mk_error:
            self.error = moms( ngalaxies, mk_error=False )
    
    
    def append( self, i, imom ):
        self.x[i] = imom.x
        self.y[i] = imom.y
        self.xx[i] = imom.xx
        self.yy[i] = imom.yy
        self.xy[i] = imom.xy
        self.xxxx[i] = imom.xxxx
        self.yyyy[i] = imom.yyyy
        self.xxyy[i] = imom.xxyy
        self.xyyy[i] = imom.xyyy
        self.xxxy[i] = imom.xxxy
        self.error.x[i] = imom.error.x
        self.error.y[i] = imom.error.y
        self.error.xx[i] = imom.error.xx
        self.error.yy[i] = imom.error.yy
        self.error.xy[i] = imom.error.xy
        self.error.xxxx[i] = imom.error.xxxx
        self.error.yyyy[i] = imom.error.yyyy
        self.error.xxyy[i] = imom.error.xxyy
        self.error.xyyy[i] = imom.error.xyyy
        self.error.xxxy[i] = imom.error.xxxy

    def calc_e1e2( self, mult_rad=1 ):
        self.e1=(self.xx-self.yy)/ (self.xx+self.yy)
        self.e2=2.*self.xy/(self.xx+self.yy)

        self.e1_err = np.sqrt( ((self.xx+self.yy)**(-2))*\
                               (self.error.xx**2*(1-self.e1)**2 + \
                                self.error.yy**2*(1+self.e1)**2-\
                                2.*(1-self.e1*self.e1)*self.error.xxyy))
                                
        self.e2_err = np.sqrt( ((self.xx+self.yy)**(-2))*\
                               ((self.error.xx**2+self.error.yy**2+\
                                 2.*self.error.xxyy)*self.e2**2+\
                                 4.*(self.error.xy**2-self.e2*\
                                     (self.error.xxxy*self.error.xyyy))))

        self.ell = np.sqrt( self.e1**2 + self.e2**2)
        self.ell[ self.ell > 1. ] = 1.0
        self.pa = 0.5*np.arctan2(self.e2, self.e1)*180./np.pi

        self.size = np.sqrt( (self.xx + self.yy)/2.)*mult_rad
        self.size[ self.xx + self.yy < 0 ] = 1
        self.a = self.size*(1.+self.ell)
        self.b = self.size*(1.-self.ell)
        

    def write_to_fits( self, filename):
        moments = { 'x':self.x, 'y':self.y, 'xx':self.xx, 'xy':self.xy,
                'yy':self.yy, 'xxxx':self.xxxx, 'xxxy':self.xxxy,
                'xxyy':self.xxyy, 'xyyy':self.xyyy, 'yyyy':self.yyyy,
                'RA':self.ra, 'DEC':self.dec, 'size':self.size,
                'e1':self.e1, 'e2':self.e2, 'ell':self.ell,
                'a':self.a, 'b':self.b, 'pos_angle':self.pa }

        mom_names = moments.keys()
        fits_columns = []
        for iColumn in mom_names:
            fits_columns.append(py.Column( name=iColumn,
                              format=np.dtype(float),
                              array=moments[iColumn] ))
            
        fits_table = py.BinTableHDU.from_columns( fits_columns )
        fits_table.writeto( filename, clobber=True )



    def fits_to_ellipse( self, filename):

        regionFile = open( filename, "wb")
        regionFile.write('# Region file format: DS9 version 4.1\n')
        regionFile.write('# Filename: dummy.fits\n')
        regionFile.write("global color=green dashlist=8 3 width=1 font='helvetica 10 normal roman' select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1\n")
        regionFile.write("physical\n")
        
        for i in xrange(len(self.ra)):
            
            regionFile.write('ellipse(%0.4f,%0.4f,%0.4f,%0.4f,%0.4f)\n' %
                             (self.x[i], self.y[i], self.a[i], self.b[i], self.pa[i]))



    
        

        
